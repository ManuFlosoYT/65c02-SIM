# ASM file writer for SID bytecode output

import os

_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))


def write_asm(bytecode, input_path, mode):
    """
    Write a 6502 ASM file containing the SID bytecode.

    Args:
        bytecode: list of integer byte values
        input_path: original MIDI file path (used to derive output filename)
        mode: mode string (e.g. 'l1') for the header comment
    """
    filename_only = os.path.splitext(os.path.basename(input_path))[0].replace(" ", "") + ".s"
    output_dir = os.path.join(_SCRIPT_DIR, "build")
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    output_file = os.path.join(output_dir, filename_only)

    print(f"Writing ASM to {output_file}...")

    with open(output_file, "w") as f:
        f.write(f"; Generated by midi_to_sid.py (Mode: {mode})\n")
        f.write(".segment \"CODE\"\n")
        f.write("reset:\n    ldx #$FF\n    txs\n    cli\n")
        f.write("    lda #<music_data\n    sta $00\n    lda #>music_data\n    sta $01\n")
        f.write("    ldy #0\n")
        f.write("play_loop:\n    lda ($00), y\n    bmi special_cmd\n    tax\n    iny\n    bne :+\n    inc $01\n:   lda ($00), y\n    sta $4800, x\n    iny\n    bne play_loop\n    inc $01\n    jmp play_loop\n")
        f.write("special_cmd:\n    cmp #$FF\n    beq stop\n    cmp #$81\n    beq do_delay\n    iny\n    bne play_loop\n    inc $01\n    jmp play_loop\n")
        f.write("do_delay:\n    iny\n    bne :+\n    inc $01\n:   lda ($00), y\n    tax\n    iny\n    bne :+\n    inc $01\n:   lda ($00), y\n    sty $02\n    tay\n")
        f.write("delay_loop:\n    cpx #0\n    bne :+\n    cpy #0\n    beq delay_done\n    dey\n:   dex\n    nop\n    nop\n    jmp delay_loop\n")
        f.write("delay_done:\n    ldy $02\n    iny\n    bne :+\n    inc $01\n:   jmp play_loop\n")
        f.write("stop:\n    lda #0\n    sta $4804\n    sta $480B\n    sta $4812\nstop_loop: jmp stop_loop\n")
        f.write("music_data:\n")

        # Chunked Write to avoid massive string construction
        chunk_size = 16
        for i in range(0, len(bytecode), chunk_size):
            chunk = bytecode[i:i+chunk_size]
            hex_str = ", ".join([f"${b:02X}" for b in chunk])
            f.write(f"    .byte {hex_str}\n")

        f.write(f".segment \"VECTORS\"\n    .word reset\n    .word reset\n    .word reset\n")

    # Size Report
    size_bytes = len(bytecode)
    size_kb = size_bytes / 1024.0
    limit_32k = 32768
    percent = (size_bytes / limit_32k) * 100.0

    print(f"Generated {output_file}")
    print(f"Size: {size_bytes} bytes ({size_kb:.1f} KB)")
    print(f"Usage: {percent:.1f}% of 32KB Limit")
    if size_bytes > limit_32k:
        print(">> WARNING: FILE EXCEEDS 32KB LIMIT!")
    else:
        print(">> OK: Fits in 32KB.")

    return output_file
