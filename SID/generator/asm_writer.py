# ASM file writer for SID bytecode output

import os
import subprocess

_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))


def write_asm(bytecode, input_path, mode):
    """
    Write a 6502 ASM file containing the SID bytecode.

    Args:
        bytecode: list of integer byte values
        input_path: original MIDI file path (used to derive output filename)
        mode: mode string (e.g. 'l1') for the header comment
    """
    filename_only = os.path.splitext(os.path.basename(input_path))[0].replace(" ", "") + ".s"
    output_dir = os.path.join(_SCRIPT_DIR, "build")
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    output_file = os.path.join(output_dir, filename_only)

    print(f"Writing ASM to {output_file}...")

    with open(output_file, "w") as f:
        f.write(f"; Generated by midi_to_sid.py (Mode: {mode})\n")
        f.write(".segment \"CODE\"\n")
        f.write("reset:\n    ldx #$FF\n    txs\n    cli\n")
        f.write("    lda #<music_data\n    sta $00\n    lda #>music_data\n    sta $01\n")
        f.write("    ldy #0\n")
        f.write("play_loop:\n    lda ($00), y\n    bmi special_cmd\n    tax\n    iny\n    bne :+\n    inc $01\n:   lda ($00), y\n    sta $4800, x\n    iny\n    bne play_loop\n    inc $01\n    jmp play_loop\n")
        f.write("special_cmd:\n    cmp #$FF\n    beq stop\n    cmp #$81\n    beq do_delay\n    iny\n    bne play_loop\n    inc $01\n    jmp play_loop\n")
        f.write("do_delay:\n    iny\n    bne :+\n    inc $01\n:   lda ($00), y\n    tax\n    iny\n    bne :+\n    inc $01\n:   lda ($00), y\n    sty $02\n    tay\n")
        f.write("delay_loop:\n    cpx #0\n    bne :+\n    cpy #0\n    beq delay_done\n    dey\n:   dex\n    nop\n    nop\n    jmp delay_loop\n")
        f.write("delay_done:\n    ldy $02\n    iny\n    bne :+\n    inc $01\n:   jmp play_loop\n")
        f.write("stop:\n    lda #0\n    sta $4804\n    sta $480B\n    sta $4812\nstop_loop: jmp stop_loop\n")
        f.write("music_data:\n")

        # Chunked Write to avoid massive string construction
        chunk_size = 16
        for i in range(0, len(bytecode), chunk_size):
            chunk = bytecode[i:i+chunk_size]
            hex_str = ", ".join([f"${b:02X}" for b in chunk])
            f.write(f"    .byte {hex_str}\n")

        f.write(f".segment \"VECTORS\"\n    .word reset\n    .word reset\n    .word reset\n")

    size_bytes = len(bytecode)
    print(f"Generated {output_file}")
    print(f"Bytecode: {size_bytes} bytes ({size_bytes / 1024.0:.1f} KB)")

    _compile_and_report(output_file, limit_bytes=32768)

    return output_file


def _compile_and_report(asm_file, limit_bytes):
    """
    Assemble and link the .s file to get the real binary size.
    Reports success with exact size, or failure with linker error and estimated excess.
    """
    name = os.path.splitext(os.path.basename(asm_file))[0]
    build_dir = os.path.dirname(asm_file)
    obj_file = os.path.join(build_dir, name + ".o")
    bin_file = os.path.join(build_dir, name + ".bin")

    # _SCRIPT_DIR = SID/generator -> SID -> project root
    project_root = os.path.dirname(os.path.dirname(_SCRIPT_DIR))
    linker_cfg = os.path.join(project_root, "Linker", "raw.cfg")

    # Step 1: Assemble
    r = subprocess.run(
        ["ca65", "--cpu", "65C02", "-o", obj_file, asm_file],
        capture_output=True, text=True
    )
    if r.returncode != 0:
        print(">> [ca65 ERROR] Assembly failed:")
        print(r.stderr.strip())
        return

    # Step 2: Link
    r = subprocess.run(
        ["ld65", "-C", linker_cfg, "-o", bin_file, obj_file],
        capture_output=True, text=True
    )
    if r.returncode != 0:
        print(f">> WARNING: Linking FAILED — likely exceeds {limit_bytes // 1024}KB limit")
        if r.stderr:
            print(r.stderr.strip())
        # Best estimate: bytecode size already printed; use obj file if available
        if os.path.exists(obj_file):
            excess = os.path.getsize(obj_file) - limit_bytes
            if excess > 0:
                print(f"   Estimated excess: ~{excess} bytes ({excess / 1024:.1f} KB) over limit")
        return

    # Step 3: Report real binary size
    bin_size = os.path.getsize(bin_file)
    bin_kb = bin_size / 1024.0
    percent = (bin_size / limit_bytes) * 100.0
    limit_kb = limit_bytes // 1024

    print(f"Binary:   {bin_size} bytes ({bin_kb:.1f} KB) — {percent:.1f}% of {limit_kb}KB")
    if bin_size > limit_bytes:
        excess = bin_size - limit_bytes
        print(f">> WARNING: FILE EXCEEDS 32KB LIMIT by {excess} bytes ({excess / 1024:.1f} KB)!")
    else:
        free = limit_bytes - bin_size
        print(f">> OK: Fits in 32KB. ({free} bytes free)")
